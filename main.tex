\input{preamble.tex}

\begin{document}
    \Header

    \BeginConspect

    \Section{? TODO: проблемы и доказательства}{}{Гагин Артур}
    
    \Subsection{Машины Тьюринга и тезис Чёрча}
   
    \begin{Def}[Машина Тьюринга]
        Да что за <<Машина Тьюринга>>?
        \begin{itemize}
            \item Абстрактная вычислительная машина.
            \item Формализация понятия алгоритма.
            \item Расширение конечного автомата.
            \item Лента (бесконечная).
            \item Головка записи-чтения (управляющее устройство), способная находиться в одном из множества состояний, которое конечно и точно задано.
            \item Это управляющее может перемещаться влево и вправо по ленте, читать и записывать в ячейки символы некоторого конечного алфавита.
            \item Существует $\epsilon$-символ, который заполняет все пустые клетки ленты.
            \item Управляющее устройство работает согласно правилам перехода, которые представляют алгоритм, реализуемый данной МТ. Каждое правило перехода предписывает машине, в зависимости от текущего состояния и наблюдаемого в текущей ячейке символа, записать в эту клетку новый символ, перейти в новое состояние и переместиться на одну клетку влево или вправо (существует некий <<синтаксический сахар>> --- остаться на месте). Некоторые состояния могут быть помечены как терминальные, и переход в любое из них означает конец работы, остановку алгоритма.
        \end{itemize}
        Это все очень интересно, но как насчет формализма?\\
        Формально: $M = \{Q, G, \epsilon, \Sigma, \delta, q_0, F\}$ --- запомните этот набор из семи элементов!
        \begin{itemize}
        \item $Q$ --- конечное, не являющееся пустым, множество состояний.
        \item $G$ --- конечный, не являющийся пустым, набор символов ленточного алфавита.
        \item $\epsilon$ --- единственный пустой символ.
        \item $\Sigma = G \backslash \{\epsilon\}$ --- набор входных символов.
        \item $\delta : (Q \backslash F) \times G \bcancel{\rightarrow}
        Q \times G \times \{L, R\}$ --- частичная функция, называемая функцией перехода, где $L$ --- сдвиг влево, а $R$ --- сдвиг вправо. Если $\delta$ не определена для текущего состояния и символа ленты, то машина останавливается.
        \item $q_0$ --- это начальное состояние.
        \item $F \subset {Q}$  --- набор конечных состояний.
        \end{itemize}
    \end{Def} 
    \begin{Rem}
        А что если мы хотим такое состояние, которое будет являться term при одном символе на ленте и nonterm при другом символе?\\
        Если немного подумать, то здесь все в порядке, поскольку мы можем сделать это состояние nonterm, перейти в другое term состояние, а при определенном символе сдвинуться, например, вправо, записав на ленту такой же символ, что был на ней.
    \end{Rem}
    \begin{Rem}
        Хоть любой конечный алфавит и не ограничен одними цифрами 0 и 1, очевидно, что мы всегда можем его представить в виде двоичных чисел, введя на нем порядок.
    \end{Rem}
    \begin{Def}[Частичная функция]
        частичная функция $f$ из множества $X$ в множество Y --- это функция из подмножества $S$ из $X$ (возможно, самого $X$) в $Y$ (обозначение: $\bcancel{\rightarrow}$). 
    \end{Def}
    \begin{Def}[Детерминированная и недетерминированная машины Тьюринга]
        Машина Тьюринга называется детерминированнй, если каждой паре состояни и ленточного символа соответствует не более одного правила. В ином случае, машина является недетерминированной.
    \end{Def}
    \begin{Def}[Тезис Черча/Тьюринга/Черча-Тьюринга]
        Есть ли отличие?\\
        На самом деле, все они говорят об одном, просто Черч в свое время придумал $\lambda$-исчисления, Тьюринг придумал Машину Тьюринга, а позже было показано, что эти формализмы эквивалентны.\\
        Сам тезис сформулируем следующим образом: Класс алгоритмически вычислимых частичных функций совпадает с классом всех функций, вычислимых на машине Тьюринга.
    \end{Def}
    \begin{Rem}
        Стоит понимать, что это именно тезис, а не теорема, ведь понятие <<алгоритмически вычислимая частичная функция>> неформально.
    \end{Rem}
    \begin{Def}[Вычислимая функция] Вычислимые функции — это множество функций         вида, $ f \colon N\ \to N $, которые могут быть реализованы на машине          Тьюринга.\\
        В качестве множества $N$ обычно рассматривается множество $B^{*}$ — множество слов в двоичном алфавите $B = \{0,1\}$, с оговоркой, что результатом вычисления может быть не только слово, но и специальное значение «неопределённость», соответствующее случаю, когда алгоритм «зависает». Таким образом, можно дать следующее определение $N$:\\
        $N=B^{*}\cup \{\operatorname{undef} \}$, где $B=\{0,1\}$, а $\operatorname{undef}$ — специальный элемент, означающий неопределённость.\\
        Роль множества $N$ может играть множество натуральных чисел, к которому добавлен элемент $ \operatorname{undef} $, и тогда вычислимые функции --- это некоторое подмножество натуральнозначных функций натурального аргумента. Удобно считать, что в качестве $N$ могут выступать различные счётные множества --- множество натуральных чисел, множество рациональных чисел, множество слов в каком-либо конечном алфавите и др. 
    \end{Def}
    \Subsection{Классы $RE$, $R$ и $co-RE$, доказательство $R = RE \cap co-RE$}
    \begin{Def}[Классы $RE$ и $co-RE$]
        Класс $RE$ (recursively enumerable) --- класс decision problems (проблемы принятия решения), для которых ответ <<да>> может быть проверен машиной Тьюринга за конечное время.
        \begin{itemize}
            \item Если на проблему ответ <<да>>, то существует некоторая процедура, которая требует конечного времени для определения этого.
            \item Ложь здесь отсутствует.
            \item Если на проблему ответ <<нет>>, то машина Тьюринга может остановиться, а может и не остановиться.
        \end{itemize}
        Класс $co-RE$ является дополнением к классу $RE$: ответ <<нет>> можно получить за конечное время абсолютно всегда, получение противоположного ответа может занять вечность.
    \end{Def}
    \begin{Def}[Формальный язык]
        Формальный язык (или просто язык) --- это множество конечных слов над конечным алфавитом.
    \end{Def}
    \begin{Def}[Класс $R$]
        $R$ --- класс decision problems, решаемых на МТ (набор всех рекурсивных языков). 
    \end{Def}
    \begin{Def}[Рекурсивный язык] Формальный язык является рекурсивным, если            существует полная машина Тьюринга (машина Тьюринга, которая останавливается для    каждого заданного ввода), которая, когда на вход подается конечная                  последовательность символов, принимает ее, если она принадлежит языку, и отвергает    ее в противном случае. 
    \end{Def}
    \begin{Thm}
        $R = RE \cap co-RE$.
    \end{Thm}
    \begin{proof}
        Обозначим за $X$ класс decision problems, содержащихся в классе $RE$, ответы <<да>> и <<нет>> на которые можно получить за конечное время. Очевидно, что $X \subset co-RE$ по определению, а также никакая другая задача, содержащаяся в $RE$ не содержится в $co-RE$. То есть, $X = RE \cap co-RE$. Однако $X = R$, так как это в точности класс decision problems, решаемых на машине Тьюринга, то есть: $R = X = RE \cap co-Re$.
    \end{proof}
    \Subsection{Проблемы Acceptence, Halting, Emptiness}
    \begin{Def}[Halting Problem]
        Проблема останова машины Тьюринга...
    \end{Def}

    \Section{}{}{Панкратов Илья}
    \par \textbf{TODO: Записать происходящее в теоремах лучше}
    \begin{Def}[Детерминированная многоленточная машина Тьюринга]
    $M = \{Q, G, \epsilon, \Sigma, \delta, q_0, F\}$, где
    \begin{itemize}
        \item $Q$ --- конечное, не являющееся пустым, множество состояний.
        \item $G$ --- конечный, не являющийся пустым, набор символов ленточного алфавита.
        \item $\epsilon$ --- единственный пустой символ.
        \item $\Sigma = G \backslash \{\epsilon\}$ --- набор входных символов.
        \item $\delta : (Q \backslash F) \times G^k \bcancel{\rightarrow}
        Q \times (G \times \{L, R\})^k$, где $k$ --- количество лент, $L$ --- сдвиг влево, а $R$ --- сдвиг вправо. Если $\delta$ не определена для текущего состояния и символа ленты, то машина останавливается.
        \item $q_0$ --- это начальное состояние.
        \item $F \subset {Q}$  --- набор конечных состояний.
    \end{itemize}
    \end{Def}
    \begin{Rem}
        Отличие ТМ с одной лентой и k-ТМ (ТМ с k лентами) заключается в том, что в функция перехода зависит от k значений на ленте, и переход осуществляет на k лентах сразу.
    \end{Rem}

    % \begin{center}
    %     \begin{figure}
    %         \includegraphics[scale=0.3]{images/k-tape-TM.png}
    %         \caption{ТМ с 3 лентами}
    %         \label{ris:k-tape-TM}
    %     \end{figure}
    % \end{center}

    \begin{Thm}
    Классы языков, распознаваемые детерминированными и многоленточными детерминированными машинами Тьюринга, совпадают.
    \end{Thm}
    \begin{proof}
        \par Одно леточная ТМ --- частный случай ТМ с множеством лент, поэтому нам достаточно свести ТМ с множеством лент к ТМ с одной лентой.
        \par Шаги для сведения k-ТМ к 1-ТМ:
        \begin{itemize}
            \item Записать входные ленты k-TM на ленту 1-TM, разделив ленты \#
            \item Пометить символы, на которые указывает каждая голова k-TM точной (или иным другим символом)
            \item Для исполнения необходимо:
                \begin{itemize}
                    \item Пройти всю ленту 1-TM, чтобы узнать головы
                    \item Пройтись с начала ленты 1-TM, чтобы сделать необходимый переход
                    \item Если символы головки уходят вправо \# запишите пробел и сдвиг содержимого ленты
                \end{itemize}
        \end{itemize}
    \end{proof}

    % \begin{figure}
    %     \includegraphics[width=1\linewidth]{images/transform-k-TM-to-1-TM.png}
    %     \caption{Переход от k-TM к 1-TM}
    %     \label{ris:transform}
    % \end{figure}
        
    \begin{Rem}
        Судя по всему в данном способе есть недостаток, если ленты на k-TM бесконечны, в таком случае можно на ленту 1-TM записывать данные с лент k-TM с помощью кортежей длинны k, где каждый i кортеж будет описывать символы на i позиции на каждой ленте.
    \end{Rem}

    \begin{Thm}
    Классы языков, распознаваемые детерминированными и недетерминированными машинами Тьюринга, совпадают.
    \end{Thm}
    \begin{proof}
        \par Мы будем обходить дерево NDTM в ширину, т. к. при обходе в глубину мы бы могли попасть в ветку, в которой зависнем навсегда. Нам нужно сохранять, в какой месте дерева мы сейчас находимся. Для этого мы пронумеруем вершины по порядку на каждом уровне поиска в ширину, и будем записывать последовательность вершин, которую мы выбрали, например, 211 --- выбрали вторую вершину, затем первую, затем снова первую. И в общем для перевода NDTM в  DTM, нам понадобится три ленты и следующие шаги:
        \begin{enumerate}
            \item Найдём b --- максимальное число недетерминированных выборов, которое мы можем сделать на любом узле. (Например 2)
            \item Рассмотрим набор строк, содержащий все числа от 1 до b ( $\sigma = \{1, 2\} $
            \item Будем проходить по набору, содержащему все возможные комбинации строк из $\sigma$ $\sigma^+ = \{1, 12, 13, ..., 123, ..., 21, ..., 213, ..., b1, ...\}$ ($\sigma^+ = \{1, 2, 11, 12, 21, 22, 111, 112, ...\}$)
            \item Создадим NDT, которая будет выполнять этот алгоритм, принимающая b в качестве входных данных и записывающая члены $\sigma^+$ на свою входную ленту.
        \end{enumerate}

        \par Построим DTM, использующую верхний алгоритм и три ленты, где лены будут отвечать за следующее:
        \begin{enumerate}
            \item Входные данные NDTM
            \item Отвечает за симуляцию исполнения каждого выбора 
            \item Отвечает за DTM, которая будет строить нам $\sigma^+$.
        \end{enumerate}

        \par Как такая машина будет работать? Будем проходится по следующему алгоритму:
        \begin{enumerate}
            \item Копируем содержимое ленты 1 на ленту 3, затем берём путь, сгенерированный на ленте 3.
            \item Очищаем ленты 2 и 3, а затем начинаем алгоритм сначала, пока не исследуем все возможные пути в дереве, если
                \begin{enumerate}
                    \item Закончились пути на 3 ленте
                    \item Достигли отклоняющего состояния на второй ленте
                    \item Если на 3 ленте был сгенерирован путь, которого не существует. Например, у i узла один ребёнок, а путь выглядит так i2.
                \end{enumerate}
            \item Если мы встретили только отклоняющие состояние, то отклоняем входные данные, если встретили принимающее состояние, то принимаем входные данные.
        \end{enumerate}
    \end{proof}

    \Section{?}{}{Гагин Артур}
        
    \Subsection{Построение универсальной машины Тьюринга}
    \begin{Def}[Универсальная машиина Тьюринга] Универсальная машина Тьюринга ---        такая машина, которая может заменить собой любую машину Тьюринга. Получив на     вход программу и входные данные, она вычисляет ответ, который вычислила бы по      входным данным машина Тьюринга, чья программа была дана на вход.
    \end{Def}
    \begin{Def}[Построение УМТ] 
    \end{Def}

    \Section{4?}{}{Гагин Артур}
    \Subsection{Совпадение RE с классом языков, распознаваемых с помощью counter machines c 4 счётчиками}
    \begin{Thm}
         RE совпадает с классом языков, распознаваемых с помощью counter machines c 4 счётчиками.
    \end{Thm}
    \begin{proof}
        Шаг 1: Машина Тьюринга может быть смоделирована двумя стеками.\\
        Машина Тьюринга состоит из конечного автомата и бесконечной ленты, изначально заполненной нулями, на которые машина может записывать единицы и нули. В любой момент головка чтения/записи машины указывает на одну ячейку на ленте. В этот момент эту ленту можно концептуально разрезать пополам. Каждую половину ленты можно рассматривать как стопку, где верхняя часть — это ячейка, ближайшая к головке чтения/записи, а нижняя — на некотором расстоянии от головки, при этом все нули на ленте находятся за нижней частью. Соответственно, машину Тьюринга можно смоделировать с помощью конечного автомата, а добавив к нему два стека. Перемещение головки влево или вправо эквивалентно извлечению бита из одного стека и перемещению его в другой. Запись эквивалентна изменению бита перед его отправкой.\\
        Шаг 2: Стек может быть смоделирован двумя счетчиками. 
        Стек, содержащий нули и единицы, может быть смоделирован двумя счетчиками, когда биты в стеке рассматриваются как представляющие двоичное число (самый верхний бит в стеке является наименее значащим битом). Помещение нуля в стек эквивалентно удвоению числа. Помещение единицы эквивалентно удвоению и добавлению 1. Выталкивание эквивалентно делению на 2, где остаток --- это бит, который выскочил. Два счетчика могут имитировать этот стек, в котором один из счетчиков содержит число, двоичное представление которого представляет биты в стеке, а другой счетчик используется в качестве блокнота. Чтобы удвоить число в первом счетчике, мы можем инициализировать второй счетчик до нуля, затем многократно уменьшать значение первого счетчика один раз и увеличивать второй счетчик дважды. Это будет продолжаться до тех пор, пока первый счетчик не достигнет нуля. В этот момент второй счетчик будет содержать удвоенное число. Уменьшение пополам выполняется путем двукратного уменьшения одного счетчика и однократного увеличения другого, и повторяется до тех пор, пока первый счетчик не достигнет нуля. Остаток можно определить по тому, достиг ли он нуля после четного или нечетного числа шагов, где четность количества шагов закодирована в состоянии автомата.
        Шаг 3: Вывод.\\
        Мы свели Машину Тьюринга к counter machines c 4 счётчиками. Исходя из определения RE, этот класс совпадает с требуемым классом.
    \end{proof}
    
    \Section{5?}{}{Гагин Артур}
    \Subsection{Определение классов сложности $P$, $NP$, $co-NP$}
    \begin{Def}[Класс сложности $P$] Классом $P$ называются все проблемы принятия решений,  которые могут быть решены детерминированной машиной Тьюринга с использованием         полиномиального количества времени вычислений или полиномиального времени.
    \end{Def}
    \begin{Example}[Задача из класса сложности $P$]
        Пусть у нас есть массив натуральных чисел, состоящий из $n$ элементов. Вопрос: содержится ли число 5 в этом массиве?\\
        Решение: Простой перебор элементов массива (если массив упорядочен, то можно воспользоваться бинарным поиском).
    \end{Example}
    \begin{Def}[Класс сложности $NP$]
        Классом $NP$ называют множество задач принятия решения, решение с ответом <<да>> каждой из которых можно проверить на детерминированной машине Тьюринга за время, не превосходящее какой-либо полином.
    \end{Def}
    \begin{Example}[Задача из класса сложности $NP$] 
        Дано число $n$. Вопрос: раскладывается ли данное число на три простых?\\
        Решение: заметим, что нельзя точно утверждать, содержится ли данная задача в классе $P$, поскольку единственное решение, которое пока что придумано --- это простой перебор, занимающий более чем полиномиальное время работы. Однако если у нас на руках существует решение данной задачи с ответом <<да>>, то мы легко можем проверить данное решение, перемножив три числа, содержащихся в решении. Если перемножение дает верный ответ, то решение верно, и наоборот. Доказательство того, что проверка занимает не более чем экспоненциальное время оставим в качестве упражнения читателям.
    \end{Example}
    \begin{Rem}
        На самом деле, решение прошлой задачи с ответом <<нет>> тоже можно проверить за экспоненциальное время. Само решение будет состоять в том, чтобы показать, что число раскладывается не на три простых, а на какое-либо другое количество. Проверка решения аналогична: перемножить и убедиться, либо же опровергнуть корректность решения. Это значит, что описанная нами задача также принадлежит и классу $co-NP$, о котором сказано ниже.
    \end{Rem}
    \begin{Rem}
        Очевидно: $P \subset NP$ (если мы можем решить задачу за полиномиальное время, то мы можем проверить решение задачи, просто решив ее).
    \end{Rem}
    \begin{Def}[Класс сложности $co-NP$]
        Классом $co$-$NP$ называют множество задач принятия решения, дополнение к которому лежит в классе $NP$. Это означает, что каждая задача, решение которой с ответом <<нет>> можно проверить на детерминированной машине Тьюринга за время, не превосходящее какой-либо полином, лежит в классе $co$-$NP$.
    \end{Def}
    \Subsection{Определение полиномиальной сводимости и класса $NP$-полных языков}
    \begin{Def}[Полиномиальная сводимость]
    Любой язык $L_1$ называется сводимым по Карпу к языку $L_2$, если существует функция $F\colon \Sigma ^{*}\mapsto \Sigma ^{*}$, вычисляемая за полиномиальное время, где F(x) принадлежит $L_2$ в том случае, если x принадлежит $L_1$. 
    \end{Def}
    \begin{Def}[Класс сложности $NP$-$complete$]
     Класс $NP$-$complete$ --- множество задач принятия решения из класса $NP$, к каждой из которых можно свести \textbf{любую} другую задачу из этого класса за полиномиальное время.
    \end{Def}
    \begin{Rem}
    Найдя алгоритм для решения любой задачи из класса $NP$-$complete$ за полиномиальное время, возможно решать каждую задачу $NP$ за полиномиальное время, а это решает проблему $P=NP$.
    \end{Rem}
    \Subsection{Взаимосвязи этих классов}
    \begin{Rem}
        Взаимосвязи:\\
        $P \subset NP$;\\
        $P \subset co-NP$;\\
        $NP \cap co-NP \neq \emptyset$.
    \end{Rem}
    \Subsection{Доказательство того, что если $NP$-полный язык лежит в $co-NP$, то $NP = co-NP$}
    \begin{Thm}
    Если $NP$-полный язык лежит в $co$-$NP$, то $NP = co$-$NP$.
    \end{Thm}
    \begin{proof}
    Пусть $L$ --- это язык из класса $co-NP$. Заметим, что дополнение к этому языку лежит в классе $NP$. Сведем это дополнение к $NP$-полному языку (за полиномиальное время), который лежит в $co-NP$. Получается, что дополнение к языку $L$ лежит в классе $co-NP$. Данное рассуждение мы можем проделать для любого $co-NP$ языка. Получается, что дополнения к каждой задаче лежат в $co-NP$, но эти дополнения по определению лежат в $NP$, а значит $NP = co-NP$.
    \end{proof}


    \Section{x}{}{Гагин Артур}

    \Section{x}{}{Гагин Артур}
    \Subsection{Теорема Кука-Левина об NP-полноте задачи CNF-SAT}
    \begin{Def}[Булева формула]
        Булева формула --- формула логики высказываний.
    \end{Def}
    \begin{Rem}
        Формула называется тождественно истинной (ложной), если она истинна (ложна) при любых значениях переменных. Две булевы формулы называются эквивалентными тогда и только тогда, когда они истинны на одном и том же подмножестве множества значений аргументов.
    \end{Rem}
    \begin{Def}[Задача SAT]
    Задача SAT --- это задача выполнимости булевых формул. Экземпляром задачи является булева формула, состоящая только из имён переменных, скобок и операций  $\wedge$ (И), $\vee$ (ИЛИ) и $\neg$ (HE). Задача заключается в следующем: можно ли назначить всем переменным, встречающимся в формуле, значения ложь и истина так, чтобы формула стала истинной.
    \end{Def}
    \begin{Def}[Задача CNF-SAT]
    Определение почти аналогично, однако на булеву формулу накладывается ограничение: она должна быть записана в конъюнктивной нормальной форме (должна иметь вид конъюнкции дизъюнкций литералов).
    \end{Def}
    \begin{Rem}
        Любая булева формула может быть приведена к КНФ.
    \end{Rem}
    \begin{Example}
        Формулы в КНФ:\\
        $\neg A\wedge (B\vee C)$;\\
        $(A\vee B)\wedge (\neg B\vee C\vee \neg D)\wedge (D\vee \neg E)$;\\
        $A\wedge B$.\\
        Формулы не в КНФ:\\
        $\neg (B\vee C)$;\\
        $(A\wedge B)\vee C$;\\
        $A\wedge (B\vee (D\wedge E))$.
    \end{Example}
    \begin{Def}[Задача 3-SAT]
    Задача 3-SAT --- частный случай задачи SAT, где булева формула записана в 3-конъюнктивной нормальной форме.
    \end{Def}
    \begin{Def}[k-КНФ]
    k-конъюнктивной нормальной формой называют конъюнктивную нормальную форму, в которой каждая дизъюнкция содержит ровно k литералов.
    \end{Def}
    \begin{Example}
    Следующая формула записана в 2-КНФ:
    $(A\lor B)\land (\neg B\lor C)\land (B\lor \neg C)$.
    \end{Example}
    \begin{Def}[Задача 1-in-3-SAT]
    Задача 1-in-3-SAT --- частный случай задачи 3-SAT, где каждая дизъюнкция содержит три литерала, только один из которых может быть правдив (TRUE).
    \end{Def}
    \begin{Thm}[Теорема Кука-Левина]
    Задача CNF-SAT выполнимости является NP-полной. То есть она находится в NP, и любая задача в NP может быть сведена за полиномиальное время детерминированной машиной Тьюринга к булевой задаче выполнимости.
    \end{Thm}
    \begin{proof}
    TODO
    \end{proof}
    \begin{Rem}
    Из того, что CNF-SAT является NP-complete, следует то, что SAT является NP-complete (TODO: why?).
    \end{Rem}

    \Subsection{co-NP-полнота задачи TAUTOLOGY}
    \begin{Def}[Тавтология]
    Тавтологией называется формула или утверждение, которое верно во всех возможных интерпретациях.
    \end{Def}
    \begin{Example}
        $x \neq y \lor x = y$.
    \end{Example}
    \begin{Def}[co-NP-complete]
    Язык $L$ называется co-NP-complete, если любой co-NP язык можно свести к этому языку за время, не превосходящее какой-либо полином.
    \end{Def}
    \begin{Def}[Задача TAUTOLOGY]
    Задача TAUTOLOGY --- задача определения тавтологии в булевой формуле. Если ответ на экземпляр задачи <<да>>, то необходимо показать, что при любых значениях литералов булева формула верна. Если ответ <<нет>>, то достаточно продемонстрировать один контрпример.
    \end{Def}
    \begin{Thm}
    Задача TAUTOLOGY является co-NP задачей.
    \end{Thm}
    \begin{proof}
    Это, на самом деле, довольно очевидно, поскольку решение с ответом <<нет>>, вместе с которым представлен контрпример, можно легко проверить на корректность, просто подставив в булеву формулу значения литералов и убедившись в правдивости решения (в его ложности).
    \end{proof}
    \begin{Thm}
    Задача TAUTOLOGY является co-NP-полной задачей.
    \end{Thm}
    \begin{proof}
    Проблема определения того, существует ли какая-либо оценка, которая делает формулу истинной --- проблема булевой выполнимости. Проблема проверки тавтологии эквивалентна этой проблеме, потому что проверка того, что предложение S является тавтологией, эквивалентна проверке того, что не существует оценки, удовлетворяющей $\lnot S$. Известно, что проблема булевой выполнимости является NP-полной. Следовательно, тавтология co-NP-полна. 
    \end{proof}
    \Section{x}{}{Гагин Артур}
    \Subsection{Доказательство NP-полноты простых задач: 3-SAT, 1-in-3-SAT, SUBSET SUM, SYSTEM OF INCONGRUENCES}
    \begin{Thm}
        3-SAT является NP-полной задачей.
    \end{Thm}
    \begin{proof}
        Мы можем преобразовать любую задачу L $\in$ NP в задачу CNF-SAT за полиномиальное время (Теорема Кука-Левина). Значит, нам надо доказать, что задачу CNF-SAT можно свести до 3-SAT задачи за полиномиальное время.\\
        Пусть представление CNF исходной задачи SAT равно:
        $$\phi = C_1 \ \wedge C_2 \wedge ... \wedge C_n.$$ Представление $\phi$ выполнимо, если все $C_i$ выполнимы.\\
        Без потери общности предположим, что предложение $C_r$ содержит больше, чем 3 литерала:
        $$C_r = (a_1 \vee a_2 \vee ... \vee a_m), m>3,$$ где каждый $a_i$ выбирается из набора литералов:  $$x_1, x_2, ...,x_m, \neg x_1, \neg x_2, ..., \neg x_m.$$\\
        Пусть $$A = a_3 \vee a_4 \vee ... \vee a_m;$$
        $$C_r = a_1 \vee a_2 \vee A.$$\\
        Определим $C'_r$ следующим образом:
        $$C'_r = (a_1 \vee a_2 \vee y) \wedge (\neg y \vee A),$$ где $y$ --- новая переменная, которую мы вводим, чтобы составить предложение с 3 литералами.\\
        Эта же процедура может быть применена повторно ко второму предложению в $C'_r$, пока не останется предложений с более чем тремя оставшимися литералами.\\
        Теперь нам нужно доказать, что $C'_r$ и $C_r$ равновероятны.\\
        > Покажем, что если $C'_r$ выполнимо, то и $C_r$ выполнимо:
        $$(a_1 \vee a_2 \vee y)=1,\ (\neg y \vee A) = 1$$
        Если $y = 0$:
        $$C_r^\prime = (a_1 \vee a_2 \vee 0) \wedge (1 \vee A)$$
        $$ = (a_1 \vee a_2) \wedge (1) $$
        $$(a_1 \vee a_2) = 1$$
        Очевидно, что, если $C_r$ выполнимо, то и $(a_1 \vee a_2) = 1$ выполнимо.\\
        Если $y=1$:
        $$C_r^\prime = (a_1 \vee a_2 \vee 1) \wedge (0 \vee A)$$
        $$(A) = 1$$
        Очевидно, что, если $C_r$ выполнимо, то и $(A) = 1$ выполнимо.\\
        > Покажем, что если $C_r$ выполнимо, то $C'_r$ выполнимо.\\
        Если $a_1 = 1$ или $a_2 = 1$, то $C'_r = 1$, потому что:
        $$C'_r = (a_1 \vee a_2 \vee y) \wedge (1 \vee A) $$
        Если $a_1 = 0$, $a_2 = 0$, тогда $A = 1$. Назначая $y = 1$, мы можем сделать $C'_r$ выполнимым.\\
        Используя описанную выше процедуру, $C_r \forall r$, где количество литералов больше 3 может быть преобразовано в предложения с не более 3 чем равновероятными переменными (если литералов меньше трех, можем добавить нули в предложения, дополнив количество до трех). Из приведенного выше доказательства мы видим, что для этого требуется полиномиальное время по количеству литералов в каждом предложении.
    \end{proof}
    \begin{Thm}
        1-in-3-SAT является NP-полной задачей.
    \end{Thm}
    \begin{proof}
        Для доказательства достаточно свести 3-SAT задачу к задаче 1-in-3-SAT за полиномиальное время.\\
        Пусть $(x \vee y \vee z)$ будет предложением в формуле 3-SAT. Добавим 4 новые булевые переменные $a_1, ..., a_4$, которые будут использоваться для моделирования этого предложения и никаких других. Тогда формула $$R(\neg x,a_1, a_2) \wedge R(a_2, y, a_3) \wedge R(a_3, a_4, \neg z)$$ выполнима некоторой настройкой свежих переменных тогда и только тогда, когда по крайней мере одно из значений x, y или z является истинным (иными словами, существует такой набор из 4 новых булевым переменных, чтобы все три предложения в формуле выше содержали ровно(!) 1 истинное значение). Таким образом, любой экземпляр 3-SAT с m предложениями и n переменными может быть преобразован в равноудовлетворяемый экземпляр 1-in-3-SAT с $3m$ предложениями и $n + 4m$ переменными.
    \end{proof}
    \begin{Def}[Задача SSP]
        Задача о сумме подмножеств (SUBSET SUM PROBLEM) заключается в нахождении (хотя бы одного) непустого подмножества некоторого набора чисел, чтобы сумма чисел этого подмножества равнялась нулю.
    \end{Def}
    \begin{Example}
        Пусть задано множество $\{-1, -3, -2, 5, 8\}$, тогда подмножество $\{-3, -2, 5\}$ даёт в сумме ноль.
    \end{Example}
    \begin{Thm}
        Задача SSP является NP-полной.
    \end{Thm}
    \begin{proof}
    TODO:
    \url{https://neerc.ifmo.ru/wiki/index.php?title=NP-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D0%B0_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8_%D0%BE_%D1%81%D1%83%D0%BC%D0%BC%D0%B5_%D0%BF%D0%BE%D0%B4%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B0}
    \end{proof}
    \begin{Def}[Задача SYSTEM OF INCONGRUENCES]
    TODO
    \end{Def}

    \Section{?}{}{Гагин Артур}
    \Subsection{NP-полнота задачи о линейных диофантовых уравнениях в N, класс задач NP-hard}
    \begin{Def}[Класс NP-hard]
         Задача $X$ является NP-сложной, если существует NP-полная задача $Y$, такая, которая сводится к $X$ полиномиальному времени.
    \end{Def}
    \begin{Rem}
        Поскольку любая NP-полная задача может быть сведена к любой другой NP-полной задаче за полиномиальное время, 
        NP $\cap$ NP-hard = NP-complete.
    \end{Rem}
    \begin{Def}[Диофантовы уравнения]
        Диофантовыми уравнениями называются уравнения в целых числах.
    \end{Def}
    \begin{Thm}
        Задача о линейных диофантовых уравнениях в N является NP-полной.
    \end{Thm}
    \begin{proof}
        TODO (доказываем, что задача лежит в NP + доказываем, что задача лежит в NP-hard).
    \end{proof}

    \Section{?}{}{Гагин Артур}
    \Subsection{Задачи VERTEX COVER, CLIQUE и INDEPENDENT SET}
    \begin{Def}[Вершинное покрытие]
    Вершинное покрытие для неориентированного графа $G=(V,E)$ --- это множество его вершин $S$, такое, что, у каждого ребра графа хотя бы один из концов входит в вершину из $S$.
    \end{Def}
    \begin{Def}[Задача VERTEX COVER]
    В общем случае, задача о вершинном покрытии состоит в поиске вершинного покрытия наименьшего размера для заданного графа (этот размер называется числом вершинного покрытия графа). Примером задачи вершинного покрытия является граф $G=(V, E)$ и натуральное число $k$, и задача состоит в том, чтобы проверить, существует ли вершинное покрытие размера не более $k$ в $G$.
    \end{Def}
    \begin{Thm}
        Задача VERTEX COVER является NP-полной задачей.
    \end{Thm}
    \begin{proof}
        Докажем, что задача VERTEX COVER является NP задачей, а потом, что она является NP-трудной.\\
        > Если какая-либо проблема находится в NP, то, учитывая «сертификат» (решение) проблемы и экземпляр проблемы (в данном случае граф $G$ и положительное целое число $k$), мы сможем проверить (проверить правильность данного решения) сертификат за полиномиальное время.
        Сертификатом задачи покрытия вершин является подмножество $V'$ множества $V$, которое содержит вершины покрытия вершин. Мы можем проверить, является ли множество $V'$ вершинным покрытием размера $k$, используя следующую стратегию (для графа $G(V, E)$):\\
        * пусть $count$ будет целым числом\\
        * установить счетчик на 0\\
        * для каждой вершины $v$ в $V'$\\
        * удалить все ребра, смежные с $v$, из множества $E$\\
        * увеличить счетчик на 1\\
        * если $count = k$ и $E$ пусто, тогда данное решение верно\\
        * иначе данное решение неверно.\\
        Легко видеть, что это можно сделать за полиномиальное время. Таким образом, задача покрытия вершин относится к классу NP.\\
        > Чтобы доказать, что вершинное покрытие является NP-трудным, мы возьмем некоторую задачу, которая уже доказана как NP-сложная, и покажем, что эту задачу можно свести к задаче о вершинном покрытии. Для этого мы рассмотрим задачу CLIQUE (о ней можно прочитать ниже), которая является NP-полной (и, следовательно, NP-трудной).\\
        Примером проблемы клики является граф $G(V, E)$ и целое неотрицательное число $k$, и нам нужно проверить существование клики размера $k$ в графе $G$.\\
        Теперь нам нужно показать, что любой экземпляр $(G, k)$ задачи клики можно свести к экземпляру задачи вершинного покрытия. Рассмотрим граф $G'$, который состоит из всех вершин $G$,однако мы уберем все ребра из $G$, а каждую пару вершин, которая не была соединена в графе $G$ соединим в нашем новом графе. Назовем этот граф дополнением к $G$. Теперь задача о том, существует ли в графе $G$ клика размера $k$ --- это то же самое, что и задача о том, существует ли вершинное покрытие размера $|V| - k$ в $G'$. Нам нужно показать, что это действительно так.\\
        В одну сторону: предположим, что в $G$ есть клика размера $k$. Пусть множество вершин клики равно $V'$. Это означает $|V'| = k$. В дополнительном графе $G'$ выберем любое ребро $(u, v)$. Тогда хотя бы один из $u$ или $v$ должен принадлежать множеству $V - V'$. Это связано с тем, что если бы и $u$, и $v$ принадлежали множеству $V'$, то ребро $(u, v)$ принадлежало бы $V'$, что, в свою очередь, означало бы, что ребро $(u, v)$ принадлежит $G$. Это невозможно, так как $(u, v)$ не принадлежит $G$. Таким образом, все ребра в $G'$ покрываются вершинами множества $V - V'$.\\
        В другую сторону: теперь предположим, что существует вершинное покрытие $V''$ размера $|V| - k$. Это означает, что все ребра в $G'$ соединены с некоторой вершиной в $V''$. В результате, если мы выберем любое ребро $(u, v) из G'$, оба они не могут быть вне множества $V''$. Это означает, что все
        ребра $(u, v)$, такие что и $u$, и $v$ лежат вне множества $V''$, принадлежат $G$, т. е. эти ребра составляют клику размера $k$.\\
        Таким образом, можно сказать, что клика размера $k$ в графе $G$ существует тогда и только тогда, когда существует вершинное покрытие размера $|V| – k$ в $G'$, и, следовательно, любой пример задачи о кликах может быть сведен к примеру задачи о вершинном покрытии. Таким образом, вершинное покрытие является NP-сложной задачей. Поскольку вершинное покрытие относится к классам NP и NP-hard, оно является NP-complete задачей.


    \end{proof}
    \begin{Def}[Задача CLIQUE]
        Кликой в неориентированном графе называется подмножество вершин, каждые две из которых соединены ребром графа. Иными словами, это полный подграф первоначального графа. Размер клики определяется как число вершин в ней. Задача о клике существует в двух вариантах: в задаче распознавания требуется определить, существует ли в заданном графе $G$ клика размера $k$, в то время как в вычислительном варианте требуется найти в заданном графе $G$ клику максимального размера (нас, по большей части, интересует первый вариант).
    \end{Def}
    \begin{Thm}
        Задача CLIQUE является NP-полной.
    \end{Thm}
    \begin{proof}
         Докажем, что задача является NP задачей, а потом, что она является NP-трудной.\\
         > Сертификат (решение) представляет собой подмножество вершин $V'$, состоящее из вершин, принадлежащих клике. Мы можем проверить это решение, проверив, что каждая пара вершин, принадлежащих решению, является смежной, просто проверив, что они имеют общее ребро друг с другом. Это можно сделать за полиномиальное время, то есть $O(V + E)$, используя следующую стратегию для графа $G(V, E)$:\\
         * $flag = true$\\
         * Для каждой пары $\{u, v\}$ в подмножестве $V’$:
         \begin{itemize}
         \item Проверить, что эти вершины $\{u, v\}$ имеют общее ребро.
        \item Если ребра нет, то $flag = false$, затем $break$.
        \end{itemize}
         * Если $flag = true$: Решение верно\\
         * Иначе: Решение не является верным.\\
         > Чтобы доказать, что задача о кликах NP-сложна, воспользуемся помощью задачи, которая уже является NP-трудной, и покажем, что эту задачу можно свести к задаче о кликах.\\
         Для этого рассмотрим задачу о независимом множестве (INDEPENDENT SET, о которой можно прочитать ниже), которая является NP-полной (и, следовательно, NP-сложной). Каждый экземпляр задачи о независимом множестве, состоящий из графа $G(V, E)$ и целого числа $K$, может быть преобразован в требуемый граф $G'(V', E')$ и $K'$ задачи клики. Построим граф $G'$ следующими модификациями:\\
         $V' = V$, то есть все вершины графа $G$ являются частью графа $G'$, $E'= \overline{E}$ (дополнение то есть ребра, отсутствующие в исходном графе G).\\
         Граф $G'$ является дополнительным графом $G$. Время, необходимое для вычисления дополнительного графа $G'$, требует обхода всех вершин и ребер.
        Временная сложность: $O(V+E)$.\\
        Теперь мы докажем, что проблема вычисления клики действительно сводится к вычислению независимого множества. Редукция может быть доказана следующими двумя утверждениями:\\
        \begin{itemize}
            \item Предположим, что граф $G$ содержит клику размера $K$. Наличие клики означает, что в $G$ имеется $K$ вершин, каждая из которых соединена ребром с остальными вершинами. Это также показывает, что, поскольку эти ребра содержатся в $G$, они не могут присутствовать в $G'$. В результате эти $K$ вершин не смежны друг с другом в $G'$ и, следовательно, образуют независимое множество размера $K$.
            \item Предположим, что дополнительный граф $G'$ имеет независимое множество вершин размера $K'$. Ни одна из этих вершин не имеет общего ребра с другими вершинами. Когда мы дополняем граф, чтобы получить $G$, эти $K$ вершин будут иметь общее ребро и, следовательно, станут смежными друг с другом. Следовательно, в графе $G$ будет клика размера $K$.
        \end{itemize}
        Таким образом, мы можем сказать, что в графе $G$ есть клика размера $K$, если в $G'$ существует независимое множество размера $K$ (дополнительный граф). Следовательно, любой случай проблемы клики может быть сведен к примеру проблемы независимого множества. Таким образом, проблема клики является NP-трудной.
    \end{proof}
    \begin{Rem}
        Размышления в прошлом доказательстве выглядят довольно массивными, однако все это достаточно очевидно, если немного подумать.
    \end{Rem}
    \begin{Rem}
        В доказательстве NP-полноты задачи INDEPENDENT SET мы используем задачу CLIQUE, поэтому предыдущее доказательство не является совсем корректным, поскольку доказательство циклично. Поэтому докажем, что задача о кликах NP-сложна, сведя булеву проблему выполнимости к задаче решения клики.\\
        Пусть логическое выражение будет следующим: $S = (x_1 \vee x_2 ) \wedge (\overline{x_1} \vee \overline{x_2}) \wedge (x_1 \vee x_3 )$, где $x_1 , x_2 , x_3$ --- переменные. Обозначим предложения за $C_1, C_2, C_3$. Рассмотрим вершины как $$<x_1, 1>; <x_2, 1>; <\overline{x_1}, 2>; <\overline{x_2}, 2>; <x_1, 3>; <x_3, 3>,$$ где второй член в каждой вершине обозначает номер предложения, к которому они принадлежат. Соединим эти вершины так, чтобы:
        \begin{itemize}
            \item никакие две вершины, принадлежащие одному предложению, не были связаны;
            \item никакая переменная (первый элемент вершины) не связана со своим дополнением (одинаковые переменные должны быть связаны).
        \end{itemize}
        Таким образом, граф $G(V, E)$ построен так, что: $$V = \{<a, i> | a \in C_i\},$$ 
        $$E = \{(<a, i>, <b, j>) | i \neq j; b \neq \overline{a}\}.$$ 
        Рассмотрим подграф $G$ с вершинами $<x_2, 1>; <\overline{x_1}, 2>; <x_3, 3>$. Он образует клику размера 3 (рис.~\ref{ris:cliqueproblem}). Соответственно этому для присваивания  $<x_1 , x_2, x_3 > = <0, 1, 1>$ S принимает значение true. Следовательно, если у нас есть $k$ предложений в нашем выражении выполнимости, мы получаем максимальную клику размера $k$ и для соответствующего присвоения значений выражение выполнимости оценивается как истинное. Следовательно, для конкретного случая проблема выполнимости сводится к проблеме решения клики. Следовательно, проблема решения клики является NP-трудной. Стоит отметить, что мы рассмотрели частный случай, однако для любой булевой проблемы, сведенной к КНФ, это верно (это необходимо доказывать, но это напрямую вытекает из того, какие ограничения мы накладываем на ребра). Помимо этого, по-хорошему, необходимо доказать, что сведение происходит за полиномиальное время. Убедитесь в последнем самостоятельно.
    \end{Rem}
            \begin{figure}
        \includegraphics[width=1\linewidth]{images/cliqueproblem.jpeg}
        \caption{Граф, построенный по указанным правилам}
        \label{ris:cliqueproblem}
        \end{figure}
    \begin{Def}[Задача INDEPENDENT SET]
        Задача INDEPENDENT SET заключается в нахождении множеств  вершин в графе размера $k$, никакие две вершины из которых не являются смежными. Decision problem вопрос можно поставить следующим образом: существует ли множество определенного размера.
    \end{Def}
    \begin{Thm}
        Задача INDEPENDENT SET является NP-полной. 
    \end{Thm}
    \begin{proof}
        Доказательство принадлежности к классу NP оставляем в качестве упражнения читателям. Доказательство принадлежности к классу NP-hard легко проделать, изучив доказательство теоремы выше. Обратите внимание на замечание после предыдущей теоремы, поскольку оно важно.
    \end{proof}
    \Subsection{Определение FPT-алгоритмов. Примеры FPT-алгоритмов для VERTEX COVER и CLIQUE}
    \begin{Def}[FPT-алгоритм]
        Параметризированная задача P считается разрешимой с фиксированным параметром, или FPT-разрешимой (Fixed-Parameter Tractable), если она может быть решена некоторым параметризированным алгоритмом за время
        $$t(n, k) = O(n^{O(1)} * f(k))$$
        для функции $f$, зависящей только от параметра $k$.\\ 
        Порядок роста функции $f(k)$ не ограничивается. Так, возможно $f(k) = 2^{o(k)}$ или $f(k) = 2^{O(k)}$. Важно, что исключаются функции вида $f(n, k)$, например $f(n, k) = n^k$.
    \end{Def}
    \begin{Rem}
        Класс всех разрешимых с фиксированным параметром задач обозначается FPT. Соответствующие параметризированные алгоритмы, решающие такие задачи, называются FPT-алгоритмами.
    \end{Rem}
    \begin{Example}
        Примером FPT-разрешимой задачи может служить задача о вершинном покрытии графа (VERTEX COVER), когда параметром выступает размер покрытия. В самом деле, вершинное покрытие размера $k$ в графе $G$ с $n$ вершинами можно определить за время $O(n*2^k)$. Если в данной задаче в качестве параметра взять древовидную ширину $tw(G)$ графа $G$, то метод динамического программирования способен отыскать наибольшее вершинное покрытие за время $O(n * 2^{tw(G)}$) (обход в ширину ??? TODO). Следовательно, параметризация данной задачи относительно $tw(G)$ приводит к FPT-разрешимости.
    \end{Example}
    \begin{Example}
        Пример с CLIQUE ??? TODO
    \end{Example}

    \Section{?}{}{Гагин Артур}
    \Subsection{Определение классов функций FP и \#P и класс языков PP}

    \begin{Def}[Функциональная задача и класс функций FP]
        Функциональная задача --- это вычислительная задача, в которой результат более сложный, чем у задачи принятия решения. Для функциональных проблем вывод не просто TRUE или FALSE. Разница между FP и P заключается в том, что задачи в P имеют одноразрядные ответы <<да>>/<<нет>>, в то время как задачи в FP могут иметь любой результат, который может быть вычислен за полиномиальное время. 
    \end{Def}
    \begin{Example}
        Сложение пяти чисел является проблемой FP, в то время как определение того, является ли их сумма нечетной, находится в P. 
    \end{Example}
    \begin{Def}[Класс функций \#P]
        \#P может быть эквивалентно определен в терминах верификатора. Проблема решения находится в NP, если существует полиномиально проверяемый сертификат для данного экземпляра проблемы, то есть NP спрашивает, существует ли доказательство принадлежности для входных данных, правильность которых можно проверить за полиномиальное время. Класс \#P спрашивает, сколько существует сертификатов для экземпляра задачи, корректность которых можно проверить за полиномиальное время. 
    \end{Def}
    \begin{Example}
        Задача определения для данного графа $G$ и числа $k$, содержит ли граф независимое множество размера $k$, находится в $NP$. Учитывая пару $(G, k)$ в языке, сертификат представляет собой набор из $k$ вершин, которые попарно несмежны (и, следовательно, являются независимым набором размера $k$). Проверка сертификата является решением NP задачи. Подсчет количества возможных сертификатов является задачей \#P.
    \end{Example}
    \begin{Def}[Класс PP]
        PP — это класс проблем принятия решений, решаемых вероятностной машиной Тьюринга за полиномиальное время с вероятностью ошибки менее 1/2 для всех случаев. 
    \end{Def}
    \begin{Def}[Вероятностная машина Тьюринга]
        Вероятностная машина Тьюринга - это тип недетерминированной машины Тьюринга, в которой каждый недетерминированный шаг представляет собой «подбрасывание монеты», то есть на каждом шаге есть два возможных следующих хода, и машина Тьюринга вероятностно выбирает, какой ход предпринять. 
    \end{Def}

    \Subsection{Доказательство эквивалентности FP = \#P и P = PP}
    \begin{Thm}
         FP = \#P тогда, и только тогда, когда P = PP.
    \end{Thm}
    \begin{proof}
        Доказательство в правую сторону очевидно из приведенных ниже теорем.\\
        Доказательство в левую сторону приведем далее (TODO).
    \end{proof}
    \begin{Thm}
        Если FP = \#P, то PP $\subseteq$ P.
    \end{Thm}
    \begin{proof}
        Данное доказательство содержит размышления <<на пальцах>>. Если классы FP и \#P совпадают, то мы можем находить не только решение задачи, но и находить их количество за полиномиальное время. Для последнего нам требуется проверка всех решений, поэтому мы можем найти правильное решение из PP, просто проверяя решения, пока не найдем верное. Мы можем сделать это за полиномиальное время из утверждения выше. Если мы можем найти правильное решение за полиномиальное время, то это задача также принадлежит классу P (я не уверен в том, что здесь написал: TODO).
    \end{proof}
    \Subsection{Доказательство NP $\subseteq$ PP}
    \begin{Thm}
        NP $\subseteq$ PP.
    \end{Thm}
    \begin{proof}
        
    \end{proof}
    \begin{proof}
        Чтобы доказать это, покажем, что проблема NP-полной выполнимости принадлежит PP. Рассмотрим вероятностный алгоритм, который по формуле $F(x_1, x_2, ..., x_n)$ равномерно и случайным образом выбирает присваивание $x_1, x_2, ..., x_n$. Затем алгоритм проверяет, делает ли присвоение истинной формулу $F$. Если да, то выводит YES. В противном случае выводится YES с вероятностью $$\frac{1}{2} - \frac{1}{2^{n+1}}$$ и НЕТ с вероятностью $$\frac{1}{2} + \frac{1}{2^{n+1}}.$$
        Если формула невыполнима, алгоритм всегда будет выводить ДА с вероятностью $$\frac{1}{2} - \frac{1}{2^{n+1}} < \frac{1}{2}.$$ Если существует удовлетворяющее задание, оно выдаст YES с вероятностью не менее $$(\frac{1}{2} - \frac{1}{2^{n+1}}) * (1 - \frac{1}{2^n}) = \frac{1}{2} + \frac{1}{2^{n+1}} > \frac{1}{2}$$ (ровно 1/2, если он выбрал неудовлетворительное задание, и 1, если он выбрал удовлетворяющее задание, усреднение до некоторого числа, превышающего 1/2). Таким образом, этот алгоритм ставит выполнимость в PP. 
    \end{proof}


    \Section{?}{}{Гагин Артур}
    \Subsection{Замкнутость класса PP относительно дополнения}
    \begin{Thm}
        PP = co-PP.
    \end{Thm}
    \begin{proof}
        Пусть $L$ --- язык в PP, а $L^c$ --- его дополнение. По определению PP существует полиномиальный вероятностный алгоритм A со свойством, что
        $$x \in L \Rightarrow \Pr [A \ {\text{accepts}} \ x] > {\frac{1}{2}} \quad {\text{и}} \quad x \not \in L \Rightarrow \Pr [A \ {\text{accepts}} \ x] \leq {\frac{1}{2}}.$$
        Будем утверждать, что без ограничения общности первое неравенство всегда строгое; из этого утверждения можно вывести теорему: пусть $A^{c}$ является машиной, которая такая же, как $A$, за исключением того, что $A^{c}$ принимает входные данные, когда $A$ отклонила бы, и наоборот. Тогда:
        $$x \in L^{c} \Rightarrow \Pr [A^{c} \ {\text{accepts}} \ x] > {\frac{1}{2}} \quad {\text{и}} \quad x \not \in L^{c} \Rightarrow \Pr [A^{c} \ {\text{accepts}} \ x] < {\frac{1}{2}}.$$
        что подразумевает, что $L^{c}$ содержится в PP.\\
        Утверждение, ссылающеся на <<без ограничения общности>>, можно доказать (TODO).
    \end{proof}

    \Section{?}{}{Гагин Артур}
    \Subsection{Alternating Turing machine и класс AP}
    \begin{Def}[Переменная машина Тьюринга]
        Переменная машина Тьюринга — это недетерминированная машина Тьюринга, состояния которой делятся на два набора: экзистенциальные состояния и универсальные состояния. Экзистенциальное состояние является принимающим, если какой-то переход приводит к принимающему состоянию; универсальное состояние является принимающим, если каждый переход приводит к принимающему состоянию. (Таким образом, универсальное состояние без переходов принимает безоговорочно; экзистенциальное состояние без переходов безоговорочно отвергает). Машина в целом принимает слово, если начальное состояние принимает слово.\\
        Формально:\\
        Переменная машина Тьюринга представляет собой кортеж из 5 элементов. $M = (Q, \Gamma, \delta, q_{0}, g)$, где:

        $Q$ --- это конечное множество состояний;\\
        $\Gamma$ --- это конечный ленточный алфавит;\\
        $\delta : Q \times \Gamma \rightarrow {\mathcal {P}(Q\times\Gamma\times\{L,R\}})$ называется функцией перехода (L сдвигает голову влево, а R сдвигает голову вправо);\\
        $q_{0} \in Q$ --- это начальное состояние;\\
        $g : Q \rightarrow \{\wedge, \vee, \text{accept}, \text{reject} \}$ определяет тип каждого состояния.\\
        Если М находится в состоянии $q\in Q$ с $g(q) = \text{accept}$, то эта конфигурация считается принимающей, а если $g(q) = \text{reject}$, то говорят, что конфигурация отклоняется. Конфигурация $g(q) = \wedge$ считается принимающей, если все конфигурации, достижимые за один шаг, принимаются, и отклоняющей, если некоторая конфигурация, достижимая за один шаг, отклоняется. Конфигурация $g(q) = \vee$ считается принимающей, когда существует некоторая конфигурация, достижимая за один шаг, которая принимается, а отклоняющей, когда все конфигурации, достижимые за один шаг, отклоняются. Говорят, что $M$ принимает входную строку $w$, если начальная конфигурация $M$ принимается (отклоняет входную строку, если исходная конфигурация отклоняется).
    \end{Def}
    \begin{Def}[Класс AP]
        Класс AP является набором задач, решаемых с помощью переменной машины Тьюринга за полиномиальное время.
    \end{Def}
    \Subsection{Совпадение AP и PSPACE}
    \begin{Def}[Класс PSPACE]
        Класс PSPACE представляет собой набор всех задач принятия решений, которые могут быть решены машиной Тьюринга с использованием полиномиального объема памяти.
    \end{Def}
    \begin{Rem}
        Детерминированная машина Тьюринга может имитировать недетерминированную машину Тьюринга, не требуя гораздо большего пространства (даже если это может занять гораздо больше времени). Это значит, что рассуждать о классе PSPACE можно, используя как ДМТ, так и НМТ.
    \end{Rem}
    \begin{Thm}
        AP = PSPACE.
    \end{Thm}
    \begin{proof}
        Вложение AP $\subset$ PSPACE доказывается обычным образом: рекурсивный алгоритм будет работать на полиномиальной памяти. Обратное следует из теоремы о PSPACE-полноте языка TQBF (о нем написано ниже): машина сначала вычислит формулу, которая получается в результате сводимости, а затем будет выбирать набор её аргументов, чередуя $\exists$- и $\forall$-состояния.
        (Это все??? Не совсем очевидна первая часть доказательства. TODO \url{http://ru.discrete-mathematics.org/fall2017/3/complexity/compl-book.pdf})
    \end{proof} 

    \Section{?}{}{Гагин Артур}
    \Subsection{AP-полнота задачи TRUE QUANTIFIED BOOLEAN FORMULAS}

    \begin{Def}[AP-полная задача]
        Задача из AP называется AP-полной, если любая задача из класса AP сводится к этой задаче за полиномиальное время.
    \end{Def}
    \begin{Def}[TQBF задача]
        TQBF задача заключается в поиске переменных, которые будут удовлетворять истинной булевой формуле с кванторами, где отсутствуют свободные переменные: $TQBF = \{\phi | \phi  \text{--- булева формула с кванторами}, Free(\phi) = \emptyset, val(\phi) = 1\}$.
    \end{Def}
    \begin{Example}
        $\forall x (y + x = 5)$. Здесь $y$ --- свободная переменная (поэтому формула не является истинной булевой формулой с кванторами).
    \end{Example}
    \begin{Example}
        $\exists y : \forall x (x \vee y)$ --- истинная булева формула с кванторами.
    \end{Example}
    \begin{Thm}
        TQBF задача является PSPACE-полной.
    \end{Thm}
    \begin{proof}
        Докажем, что TQBF является PSPACE задачей, а затем, что она является PSPACE-полной задачей.\\
        > 
    \end{proof}
    \begin{Rem}
        Из того, что TQBF задача является PSPACE-полной, следует AP = PSPACE (теорема выше). Поскольку эти классы равны, то AP-complete = PSPACE-complete (вполне очевидный факт).
    \end{Rem}
\end{document}